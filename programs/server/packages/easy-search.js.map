{"version":3,"file":"/packages/easy-search.js","sources":["easy-search/lib/easy-search-server.js","easy-search/lib/easy-search-convenience.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,mC;AACA,6D;AACA,4B;AACA,e;AACA,E;AACA,G;;AAEA,2B;AACA,iB;;AAEA,4B;AACA,kB;AACA,mB;AACA,c;AACA,qD;AACA,iD;AACA,0C;AACA,4C;AACA,uC;AACA,4C;AACA,8C;;AAEA,+B;AACA,c;AACA,U;AACA,qD;AACA,kB;AACA,mC;AACA,U;AACA,iE;AACA,0B;AACA,+B;AACA,yB;AACA,gD;AACA,+B;AACA,kC;AACA,6D;AACA,c;AACA,c;AACA,+D;AACA,kE;AACA,c;AACA,2C;AACA,+B;AACA,e;AACA,+C;AACA,4E;AACA,a;AACA,U;AACA,8C;AACA,qD;;AAEA,O;AACA,4C;AACA,M;AACA,mE;AACA,uB;AACA,O;AACA,+B;AACA,wB;;AAEA,2C;AACA,oF;AACA,W;;AAEA,sB;AACA,K;;AAEA,O;AACA,wF;AACA,M;AACA,yE;AACA,wD;AACA,O;AACA,iB;AACA,4B;AACA,e;AACA,qD;AACA,c;AACA,mC;AACA,kC;AACA,iC;AACA,e;AACA,uD;AACA,+B;AACA,2C;AACA,iC;AACA,qC;AACA,4B;AACA,8B;AACA,yC;AACA,8B;AACA,oE;AACA,yC;AACA,qB;;AAEA,kD;AACA,gG;AACA,kE;AACA,qB;AACA,mB;AACA,c;AACA,e;AACA,wE;AACA,c;AACA,mC;AACA,sC;AACA,e;AACA,4D;AACA,yC;;AAEA,iE;AACA,2E;AACA,iB;;AAEA,0D;AACA,kD;AACA,kF;AACA,sB;AACA,oD;AACA,2E;AACA,0G;AACA,sB;AACA,4C;AACA,uC;AACA,sC;AACA,0C;AACA,gC;AACA,uD;AACA,mF;AACA,6C;AACA,2B;AACA,qB;AACA,mB;AACA,c;AACA,e;AACA,oE;AACA,c;AACA,mC;AACA,+B;AACA,e;AACA,iD;AACA,kE;;AAEA,0E;AACA,8D;;AAEA,6D;;AAEA,gD;AACA,mB;;AAEA,wB;AACA,wC;AACA,6C;AACA,kB;AACA,c;AACA,e;AACA,kE;AACA,c;AACA,mC;AACA,2C;AACA,sC;AACA,yC;AACA,2B;AACA,e;AACA,yE;AACA,4B;AACA,gC;AACA,uC;AACA,0C;AACA,iD;;AAEA,yC;AACA,2B;AACA,iB;;AAEA,2B;AACA,wD;AACA,sD;AACA,0C;AACA,kB;;AAEA,qD;AACA,yE;AACA,2B;AACA,iB;;AAEA,2D;AACA,4C;AACA,iC;AACA,kC;AACA,2C;AACA,gC;AACA,qE;AACA,2C;AACA,+B;AACA,qB;;AAEA,iD;AACA,0D;AACA,qB;;AAEA,wC;AACA,mB;;AAEA,kC;AACA,c;AACA,e;AACA,0E;AACA,c;AACA,sC;AACA,4B;AACA,e;AACA,+D;AACA,wB;AACA,yC;AACA,iD;AACA,kD;AACA,qB;AACA,kB;AACA,c;AACA,e;AACA,0E;AACA,c;AACA,sC;AACA,4B;AACA,e;AACA,gD;AACA,qC;AACA,a;AACA,U;AACA,sB;AACA,e;AACA,qC;AACA,c;AACA,0B;AACA,6B;AACA,2B;AACA,e;AACA,4D;AACA,+C;AACA,c;AACA,e;AACA,c;AACA,4D;AACA,c;AACA,mC;AACA,2C;AACA,sC;AACA,yC;AACA,2B;AACA,e;AACA,yE;AACA,2B;AACA,6B;AACA,gC;AACA,0C;;AAEA,yC;AACA,2B;AACA,iB;;AAEA,oD;;AAEA,qF;AACA,qD;;AAEA,0D;AACA,mD;AACA,mB;;AAEA,6C;AACA,8B;AACA,2E;AACA,gD;AACA,uB;AACA,iB;;AAEA,wB;AACA,uE;AACA,4C;AACA,kB;AACA,c;AACA,e;AACA,wE;AACA,c;AACA,oC;AACA,2C;AACA,sC;AACA,gC;AACA,e;AACA,+D;AACA,+B;AACA,kC;AACA,0C;AACA,kG;;AAEA,wC;AACA,qD;AACA,oC;AACA,iB;;AAEA,gD;AACA,2F;AACA,8D;AACA,iB;;AAEA,qC;AACA,qC;;AAEA,sD;AACA,oC;AACA,oB;AACA,mD;AACA,iE;AACA,0D;AACA,+D;AACA,qB;;AAEA,qD;AACA,mB;;AAEA,gC;AACA,c;AACA,e;AACA,gF;AACA,c;AACA,sC;AACA,4B;AACA,e;AACA,gD;AACA,qC;AACA,a;AACA,S;AACA,M;;AAEA,Y;AACA,W;AACA,kD;AACA,U;AACA,oC;AACA,W;AACA,yC;AACA,mD;AACA,8B;AACA,a;;AAEA,qC;;AAEA,iD;AACA,mE;AACA,U;AACA,W;AACA,iC;AACA,U;AACA,+B;AACA,kC;AACA,W;AACA,wD;AACA,gC;AACA,mC;;AAEA,iE;;AAEA,kD;AACA,uF;AACA,oC;;AAEA,oE;AACA,U;AACA,W;AACA,4B;AACA,U;AACA,4D;AACA,qE;AACA,yE;AACA,wE;AACA,W;AACA,qE;AACA,iD;;AAEA,gC;AACA,wC;AACA,mC;AACA,sD;;AAEA,iE;AACA,oG;AACA,a;AACA,Y;AACA,+C;AACA,uD;AACA,iE;AACA,uD;AACA,oB;AACA,sH;AACA,a;AACA,U;AACA,W;AACA,sC;AACA,iG;AACA,U;AACA,0C;AACA,W;AACA,gD;AACA,uC;AACA,U;AACA,W;AACA,mD;AACA,U;AACA,+B;AACA,2B;AACA,sB;AACA,W;AACA,sC;AACA,iC;AACA,U;AACA,W;AACA,6C;AACA,Y;AACA,oC;AACA,2B;AACA,U;AACA,W;AACA,uC;AACA,U;AACA,+B;AACA,2B;AACA,sB;AACA,W;AACA,yC;AACA,mC;AACA,U;AACA,W;AACA,iC;AACA,W;AACA,sC;AACA,6B;AACA,U;AACA,W;AACA,gE;AACA,sE;AACA,oD;AACA,U;AACA,uE;AACA,4E;AACA,uE;AACA,sF;AACA,W;AACA,kD;AACA,+B;AACA,4C;AACA,uD;;AAEA,qC;AACA,S;AACA,M;AACA,K;;AAEA,gB;AACA,O;AACA,0C;AACA,M;AACA,2B;AACA,mC;AACA,O;AACA,wD;AACA,4B;AACA,oC;AACA,+B;AACA,8D;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;AC1dA,yE;AACA,+B;AACA,qB;AACA,K;;AAEA,gE;AACA,4B;AACA,wB;AACA,Q;AACA,E;;AAEA,sB;AACA,+C;AACA,e;AACA,4B;;AAEA,gD;AACA,sB;AACA,S;;AAEA,uG;;AAEA,4E;AACA,K;AACA,C","sourcesContent":["/**\n * @title EasySearch Server Methods\n * @overview These are all the methods exposed on the Server.\n * @author Matteo De Micheli\n * @license MIT\n *\n */\n\nEasySearch = (function () {\n    'use strict';\n\n    var ElasticSearchClient,\n        Searchers,\n        indexes = {\n            /*\n            collection: Meteor.Collection (required),\n            field: [string] || string (required),\n            sort: function (searchFields),\n            query : function (searchFields),\n            limit: number (default: 10)\n            format: string (default: mongo),\n            use : string (default: 'mongo-db')\n\n            @see defaultOptions\n            */\n        },\n        // Default config used in EasySearch.config()\n        config = {\n            host : 'localhost:9200'\n        },\n        // Default options used in EasySearch.createSearchIndex()\n        defaultOptions = {\n            'format' : 'mongo',\n            'limit' : 10,\n            /* also useable: 'elastic-search' */\n            'use' : 'mongo-db',\n            'sort' : function () {\n                return Searchers[this.use].defaultSort(this);\n            },\n            /*\n             * When using elastic-search it's the query object,\n             * while using with mongo-db it's the selector object.\n             *\n             * @param {String} searchString\n             * @return {Object}\n             */\n            'query' : function (searchString) {\n                return Searchers[this.use].defaultQuery(this, searchString);\n            }\n        },\n        Future = Npm.require('fibers/future'),\n        ElasticSearch = Npm.require('elasticsearch');\n\n    /**\n     * Return Elastic Search indexable data.\n     *\n     * @param {Object} doc      the document to get the values from\n     * @return {Object}\n     */\n    function getESFields(doc) {\n        var newDoc = {};\n\n        _.each(doc, function (value, key) {\n            newDoc[key] = \"string\" === typeof value ? value : JSON.stringify(value);\n        });\n\n        return newDoc;\n    }\n\n    /**\n     * Searchers which contain all types which can be used to search content, until now:\n     *\n     * elastic-search: Use an elastic search server to search with (fast)\n     * mongo-db: Use mongodb to search (more convenient)\n     */\n    Searchers = {\n        'elastic-search' : {\n            /**\n             * Write a document to a specified index.\n             *\n             * @param {String} name\n             * @param {Object} doc\n             * @param {String} id\n             */\n            'writeToIndex' : function (name, doc, id) {\n                // add to index\n                ElasticSearchClient.index({\n                    index : name,\n                    type : 'default',\n                    id : id,\n                    body : doc\n                }, function (err, data) {\n                    if (err) {\n                        console.log('Had error adding a document!');\n                        console.log(err);\n                    }\n\n                    if (config.debug && console) {\n                        console.log('EasySearch: Added / Replaced document to Elastic Search:');\n                        console.log('EasySearch: ' + data + \"\\n\");\n                    }\n                });\n            },\n            /**\n             * Setup some observers on the mongo db collection provided.\n             *\n             * @param {String} name\n             * @param {Object} options\n             */\n            'createSearchIndex' : function (name, options) {\n                var searcherScope = this;\n\n                if (\"undefined\" === typeof ElasticSearchClient) {\n                    ElasticSearchClient = new ElasticSearch.Client(config);\n                }\n\n                options.collection.find().observeChanges({\n                    added: function (id, fields) {\n                        searcherScope.writeToIndex(name, getESFields(fields), id);\n                    },\n                    changed: function (id, fields) {\n                        // Overwrites the current document with the new doc\n                        searcherScope.writeToIndex(name, getESFields(options.collection.findOne(id)), id);\n                    },\n                    removed: function (id) {\n                        client.delete({\n                          index: name,\n                          type: 'default',\n                          id: id\n                        }, function (error, response) {\n                          console.log('Removed document with id ( ' +  id + ' )!');\n                          console.log(error);\n                        });\n                    }\n                });\n            },\n            /**\n             * Get the data out of the JSON elastic search response.\n             *\n             * @param {Object} data\n             * @returns {Array}\n             */\n            'extractJSONData' : function (data) {\n                data = _.isString(data) ? JSON.parse(data) : data;\n\n                var results = _.map(data.hits.hits, function (resultSet) {\n                    var mongoDbDocFake = resultSet['_source'];\n\n                    mongoDbDocFake['_id'] = resultSet['_id'];\n\n                    return resultSet['_source'];\n                });\n\n                return {\n                    'results' : results,\n                    'total' : data.hits.total\n                };\n            },\n            /**\n             * Perform a search with Elastic Search, using fibers.\n             *\n             * @param {String} name\n             * @param {String} searchString\n             * @param {Object} options\n             * @param {Function} callback\n             * @returns {*}\n             */\n            'search' : function (name, searchString, options, callback) {\n                var bodyObj,\n                    that = this,\n                    fut = new Future(),\n                    index = indexes[name],\n                    searchFields = options.field;\n\n                if (!_.isObject(index)) {\n                    return;\n                }\n\n                bodyObj = {\n                    \"query\" : index.query(searchString),\n                    \"sort\" : index.sort(searchString),\n                    \"size\" : options.limit\n                };\n\n                if (\"function\" === typeof callback) {\n                    ElasticSearchClient.search(name, queryObj, callback);\n                    return;\n                }\n\n                // Most likely client call, return data set\n                ElasticSearchClient.search({\n                    index : name,\n                    body : bodyObj\n                }, function (error, data) {\n                    if (error) {\n                        console.log('Had an error while searching!');\n                        console.log(error);\n                        return;\n                    }\n\n                    if (\"raw\" !== index.format) {\n                        data = that.extractJSONData(data);\n                    }\n\n                    fut['return'](data);\n                });\n\n                return fut.wait();\n            },\n            /**\n             * The default ES query object used for searching the results.\n             *\n             * @param {Object} options\n             * @return array\n             */\n            'defaultQuery' : function (options, searchString) {\n                return {\n                    \"fuzzy_like_this\" : {\n                        \"fields\" : options.field,\n                        \"like_text\" : searchString\n                    }\n                };\n            },\n            /**\n             * The default ES sorting method used for sorting the results.\n             *\n             * @param {Object} options\n             * @return array\n             */\n            'defaultSort' : function (options) {\n                return options.field;\n            }\n        },\n        'mongo-db' : {\n            /**\n             * Set up a search index.\n             *\n             * @param name\n             * @param options\n             * @returns {*}\n             */\n            'createSearchIndex' : function (name, options) {\n                // Don't have to setup anything\n            },\n            /**\n             *\n             * Perform a really simple search with mongo db.\n             *\n             * @param {String} name\n             * @param {String} searchString\n             * @param {Object} options\n             * @param {Function} callback\n             * @returns {*}\n             */\n            'search' : function (name, searchString, options, callback) {\n                var cursor,\n                    selector,\n                    that = this,\n                    index = indexes[name];\n\n                if (!_.isObject(index)) {\n                    return;\n                }\n\n                options.limit = options.limit || 10;\n\n                // if several, fields do an $or search, otherwise only over the field\n                selector = index.query(searchString);\n\n                cursor = index.collection.find(selector, {\n                    sort : index.sort(searchString)\n                });\n\n                if (_.isFunction(callback)) {\n                    callback({\n                        'results' : _.first(cursor.fetch(), options.limit),\n                        'total' : cursor.count()\n                    });\n                }\n\n                return {\n                    'results' : _.first(cursor.fetch(), options.limit),\n                    'total' : cursor.count()\n                };\n            },\n            /**\n             * The default mongo-db query - selector used for searching.\n             *\n             * @param {Object} index\n             * @param {String} searchString\n             * @param {Obejct} options\n             * @returns {Object}\n             */\n            'defaultQuery' : function (options, searchString) {\n                var orSelector,\n                    selector = {},\n                    field = options.field,\n                    stringSelector = { '$regex' : '.*' + searchString + '.*', '$options' : '-i' };\n\n                if (_.isString(field)) {\n                    selector[field] = stringSelector;\n                    return selector;\n                }\n\n                // Convert numbers if configured\n                if (options.convertNumbers && parseInt(searchString, 10) == searchString) {\n                    searchString = parseInt(searchString, 10);\n                }\n\n                // Should be an array\n                selector['$or'] = [];\n\n                _.each(field, function (fieldString) {\n                    orSelector = {};\n                    \n                    if (_.isString(searchString)) {\n                        orSelector[fieldString] = stringSelector;\n                    } else if (_.isNumber(searchString)) {\n                        orSelector[fieldString] = searchString;\n                    }\n\n                    selector['$or'].push(orSelector);\n                });\n\n                return selector;\n            },\n            /**\n             * The default mongo-db sorting method used for sorting the results.\n             *\n             * @param {Object} options\n             * @return array\n             */\n            'defaultSort' : function (options) {\n                return options.field;\n            }\n        }\n    };\n\n    return {\n        /**\n         * Override the config for Elastic Search.\n         *\n         * @param {object} newConfig\n         */\n        'config' : function (newConfig) {\n            if (\"undefined\" === typeof newConfig) {\n                return config;\n            }\n\n            check(newConfig, Object);\n\n            config = _.extend(config, newConfig);\n            ElasticSearchClient = new ElasticSearch.Client(config);\n        },\n        /**\n         * Create a search index.\n         *\n         * @param {String} name\n         * @param {Object} options\n         */\n        'createSearchIndex' : function (name, options) {\n            check(name, String);\n            check(options, Object);\n\n            options = _.extend(_.clone(defaultOptions), options);\n\n            check(Searchers[options.use], Object);\n            options.field = _.isArray(options.field) ? options.field : [options.field];\n            indexes[name] = options;\n\n            Searchers[options.use].createSearchIndex(name, options);\n        },\n        /**\n         * Perform a search.\n         *\n         * @param {String} name             the search index\n         * @param {String} searchString     the string to be searched\n         * @param {Object} options          defined with createSearchInde\n         * @param {Function} callback       optional callback to be used\n         */\n        'search' : function (name, searchString, options, callback) {\n            var searcherType = indexes[name].use;\n\n            check(name, String);\n            check(searchString, String);\n            check(options, Object);\n            check(callback, Match.Optional(Function));\n\n            if (\"undefined\" === typeof Searchers[searcherType]) {\n                throw new Meteor.Error(500, \"Couldnt search with the type: '\" + searcherType + \"'\");\n            }\n            \n            // If custom permission check fails\n            if (_.isFunction(indexes[name].permission) \n                    && !indexes[name].permission(searchString)) {\n                return { 'results' : [], 'total' : 0 };\n            } else {\n                return Searchers[searcherType].search(name, searchString, _.extend(indexes[name], options), callback);\n            }\n        },\n        /**\n         * Get the ElasticSearchClient\n         * @see http://www.elasticsearch.org/guide/en/elasticsearch/client/javascript-api/current\n         *\n         * @return {ElasticSearchInstance}\n         */\n        'getElasticSearchClient' : function () {\n            return ElasticSearchClient;\n        },\n        /**\n         * Retrieve a specific index configuration.\n         *\n         * @param {String} name\n         * @return {Object}\n         * @api public\n         */\n        'getIndex' : function (name) {\n            return indexes[name];\n        },\n        /**\n          * Retrieve all index configurations\n          */\n        'getIndexes' : function () {\n            return indexes;\n        },\n        /**\n         * Retrieve a specific Seacher.\n         *\n         * @param {String} name\n         * @return {Object}\n         * @api public\n         */\n        'getSearcher' : function (name) {\n            return Searchers[name];\n        },\n        /**\n         * Retrieve all Searchers\n         */\n        'getSearchers' : function () {\n            return Searchers;\n        },\n        /**\n         * Makes it possible to override or extend the different\n         * types of search to use with EasySearch (the \"use\" property)\n         * when using EasySearch.createSearchIndex()\n         *\n         * @param {String} key      Type, e.g. mongo-db, elastic-search\n         * @param {Object} methods  Methods to be used, only 2 are required:\n         *                          - createSearchIndex (name, options)\n         *                          - search (name, searchString, [options, callback])\n         */\n        'extendSearch' : function (key, methods) {\n            check(key, String);\n            check(methods.search, Function);\n            check(methods.createSearchIndex, Function);\n\n            Searchers[key] = methods;\n        }\n    };\n})();\n\nMeteor.methods({\n    /**\n     * Make search possible on the client.\n     *\n     * @param {String} name\n     * @param {String} searchString\n     */\n    easySearch: function (name, searchString, options) {\n        check(name, String);\n        check(searchString, String);\n        check(options, Object);\n        return EasySearch.search(name, searchString, options);\n    }\n});\n","Meteor.Collection.prototype.initEasySearch = function (fields, options) {\n    if (!_.isObject(options)) {\n        options = {};\n    }\n\n    EasySearch.createSearchIndex(this._name, _.extend(options, {\n        'collection' : this,\n        'field' : fields\n    }));\n};\n\nif (Meteor.isClient) {\n    jQuery.fn.esAutosuggestData = function () {\n        var id,\n            input = $(this);\n\n        if (input.prop(\"tagName\") !== 'INPUT') {\n            return [];\n        }\n\n        id = EasySearch.Components.generateId(input.parent().data('index'), input.parent().data('id'));\n\n        return EasySearch.ComponentVariables.get(id, 'autosuggestSelected');\n    }\n}\n\n"]}